
generator client {
provider = "prisma-client-js"
}

datasource db {
provider = "postgresql"
url      = env("DATABASE_URL")
}

// --------------------
// ENUMS
// --------------------
enum SwipeAction {
  LIKE
  PASS
}

enum ReadSentiment {
  LIKE
  DISLIKE
  NEUTRAL
}

// --------------------
// DISTRICTS (ì„œìš¸ 25êµ¬ + ìˆ˜ì› ì¥ì•ˆêµ¬ seed)
// --------------------
model District {
  // ì˜ˆ: "SEOUL_GANGNAM", "SUWON_JANGAN"
  code      String   @id
  cityName  String   // ì˜ˆ: "ì„œìš¸íŠ¹ë³„ì‹œ", "ê²½ê¸°ë„ ìˆ˜ì›ì‹œ"
  name      String   // ì˜ˆ: "ê°•ë‚¨êµ¬", "ì¥ì•ˆêµ¬"

  createdAt DateTime @default(now())

  users     User[]
}

// --------------------
// USERS / MBTI PROFILES
// -------------------
model User {
  id            String   @id @default(cuid())
  nickname      String   @unique

  // ê°™ì€ êµ¬ ë‹¨ìœ„ ë§¤ì¹­ìš© (FKë¡œ ì˜¤íƒ€ ë°©ì§€)
  districtCode  String
  district      District @relation(fields: [districtCode], references: [code])

  // ì˜¨ë³´ë”© ê²°ê³¼(ì½”ë“œ) - FKë¡œ ìœ íš¨ê°’ ë³´ì¥
  mbtiCode      String
  mbtiProfile   ReadingTypeProfile @relation(fields: [mbtiCode], references: [code])

  // êµí™˜ íšŸìˆ˜(í‘œì‹œìš© ìºì‹œ)
  exchangeCount Int      @default(0)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // relations
  userBooks      UserBook[]
  readLogs       ReadLog[]
  swipesFrom     Swipe[]  @relation("SwipeFrom")
  swipesTo       Swipe[]  @relation("SwipeTo")

  matchesA       Match[]  @relation("MatchA")
  matchesB       Match[]  @relation("MatchB")

  readingRecords ReadingRecord[]

  @@index([districtCode, mbtiCode])
}

model ReadingTypeProfile {
  // SFI, LRG ...
  code      String  @id
  name      String
  summary   String

  createdAt DateTime @default(now())

  users     User[]
}

// --------------------
// BOOKS (Best)
// --------------------
model Book {
  id        String   @id @default(cuid())
  title     String   @unique
  author String?

  createdAt DateTime @default(now())

  // relations
  userBooks  UserBook[]
  readLogs   ReadLog[]
  records    ReadingRecord[]

  @@index([title])
}

// --------------------
// READ LOGS (ì½ì€ ì±… + ğŸ‘/ğŸ‘)
// --------------------
model ReadLog {
  id        String        @id @default(cuid())
  userId    String
  bookId    String
  sentiment ReadSentiment @default(NEUTRAL) // like dislike neural

  createdAt DateTime      @default(now())

  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book      Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([userId, bookId])
  @@index([bookId])
}

// --------------------
// USER BOOKS (êµí™˜ìš© ì‹¤ë¬¼ ì±…)
// --------------------
model UserBook {
  id            String        @id @default(cuid())
  ownerUserId   String
  bookId        String

  rating        Int?          // 1~5
  oneLineReview String?
  isAvailable   Boolean       @default(true)

  hashtags      Json? // ['','']

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  imageUrl      String? 

  owner         User @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)
  book          Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  swipes        Swipe[]
  matchAsA      Match? @relation("MatchBookA")
  matchAsB      Match? @relation("MatchBookB")

  @@index([ownerUserId, isAvailable])
  @@index([bookId, isAvailable])
}

// --------------------
// SWIPES (ì¹´ë“œ ë‹¨ìœ„ ìŠ¤ì™€ì´í”„)
// ì¹´ë“œ = ìƒëŒ€ì˜ UserBook
// --------------------
model Swipe {
  id         String      @id @default(cuid())
  fromUserId String
  toUserId   String
  userBookId String
  action     SwipeAction

  createdAt  DateTime    @default(now())

  fromUser   User @relation("SwipeFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser     User @relation("SwipeTo", fields: [toUserId], references: [id], onDelete: Cascade)
  userBook   UserBook @relation(fields: [userBookId], references: [id], onDelete: Cascade)

  // ê°™ì€ ì¹´ë“œì— ì¤‘ë³µ ìŠ¤ì™€ì´í”„ ë°©ì§€
  @@unique([fromUserId, userBookId])
  @@index([toUserId, action])
  @@index([fromUserId, createdAt])
}

// --------------------
// MATCHES (ì–‘ìª½ LIKE ì„±ë¦½ ì‹œ ìƒì„±)
// --------------------
model Match {
  id          String   @id @default(cuid())

  userAId     String
  userBId     String

  userBookAId String   @unique
  userBookBId String   @unique

  createdAt   DateTime @default(now())

  userA       User @relation("MatchA", fields: [userAId], references: [id], onDelete: Cascade)
  userB       User @relation("MatchB", fields: [userBId], references: [id], onDelete: Cascade)

  userBookA   UserBook @relation("MatchBookA", fields: [userBookAId], references: [id], onDelete: Restrict)
  userBookB   UserBook @relation("MatchBookB", fields: [userBookBId], references: [id], onDelete: Restrict)

  @@index([createdAt])
}


// --------------------
// READING RECORD + IMAGES
// --------------------
model ReadingRecord {
  id        String   @id @default(cuid())
  userId    String
  bookId    String?

  content   String?
  rating    Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book      Book? @relation(fields: [bookId], references: [id], onDelete: SetNull)

  images    ReadingRecordImage[]

  @@index([userId, createdAt])
}

model ReadingRecordImage {
  id         String   @id @default(cuid())
  recordId   String
  record     ReadingRecord @relation(fields: [recordId], references: [id], onDelete: Cascade)

  storageKey String   @unique
  url        String

  mimeType   String?
  sizeBytes  Int?
  width      Int?
  height     Int?
  order      Int      @default(0)

  createdAt  DateTime @default(now())

  @@index([recordId, order])
}